<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Architecture on lwolfs blog</title>
    <link>http://blog.lwolf.org/categories/architecture/</link>
    <description>Recent content in Architecture on lwolfs blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 25 Apr 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://blog.lwolf.org/categories/architecture/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Move infrastructure to Kubernetes</title>
      <link>http://blog.lwolf.org/post/move-infrastructure-to-kubernetes/</link>
      <pubDate>Mon, 25 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.lwolf.org/post/move-infrastructure-to-kubernetes/</guid>
      <description>

&lt;p&gt;I started trying to switch to docker about a year ago, but all tools were kind of &lt;code&gt;not-production-ready&lt;/code&gt;.
With docker-compose it was unreal to scale containers without restart. Deis looked like a black box with a lot of magic.
Then tutum appeared and it was awesome, it was, really, the first working solution. So I switched to it.
It was fine most of the time, yes it had problems with networking, yes it was annoying to copy-paste
all environment variables into each container, but it was in beta, and it was free.
But then docker bought it and decided to charge $15 per node. Yes, it became more stable, with better networking.
But for me it wasn&amp;rsquo;t doing much for me since I&amp;rsquo;m running everything on baremetal servers.&lt;/p&gt;

&lt;p&gt;And since I was needed to migrate from tutum and redo my infrastructure anyways either to docker-cloud
or to something else. Among options there were, except for docker-cloud, raw docker&amp;rsquo;s compose/swarm and kubernetes.
So, I decided to go away from docker-cloud.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h1 id=&#34;first-steps-with-kubernetes:ccb8ad9ee70a4495f2af7de194626ecd&#34;&gt;First steps with Kubernetes&lt;/h1&gt;

&lt;p&gt;First time I tried to use kubernetes even before tutum. I think v1.0 was just released when I tried it.
After few weeks playing with it, I decided to not use it in production yet. Mostly because of difficulties
with loadbalancing on baremetal.
Few weeks ago I was responsible for choosing docker management platform at work and for building cluster on it.
So I spent some time investigating current solutions and ended up building kuberenetes cluster on CoreOS.&lt;/p&gt;

&lt;p&gt;After successfull built of test multinode cluster and dev-environment at work
I spent weekend building cluster for my own projects.
This will not be the step-by-step tutorial but more like sumarization of my experience.&lt;/p&gt;

&lt;p&gt;Basicly for my side projects, I have one physical server with ESXi and a lot of virtual machines.
Before tutum I used to create one VM per project or service, and ended up with about 20 VMs.
With tutum I reduced this number to about 8-10. Only 4 of them were related to tutum: 3 VMs for tutum, 1 vm as router.
Other VMs had some lagacy parts which I didn&amp;rsquo;t want to move to docker for some reasons.&lt;/p&gt;

&lt;h1 id=&#34;building-cluster:ccb8ad9ee70a4495f2af7de194626ecd&#34;&gt;Building cluster&lt;/h1&gt;

&lt;p&gt;With this switch from tutum to kubernetes I wanted to do it as &lt;code&gt;production-like&lt;/code&gt; as possible.
Since I&amp;rsquo;m going to use CoreOS I want to use its awesome autoupdate feature, and for this I need to have
several nodes of each type: etcd, kubernetes-masters, kubernetes-minions. Since it will be small cluster
and I do not want to waste resources, I&amp;rsquo;m going to have 6 VMs for kubernetes and 1 for external loadbalancer.
3 of it will run etcd + kubernetes masters and 3 will be minions. Having 3 minions could sound like a waste of resources,
but, remember, I want to have production-like solution and with 1 minion it will be to easy to go with some stupid solutions,
like I have only 1 machine, I can use local hard drive for storage or hardcode IP address and port of this node in loadbalancer.
Also I want to be able to easily scale it to several machines.&lt;/p&gt;

&lt;p&gt;Here is a schema of what I&amp;rsquo;m going to build.

&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.lwolf.org/img/2016/04/kube-cluster-schema.png&#34; alt=&#34;Kubernetes cluster schema&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;On schema I have two loadbalancer, but in fact its one.&lt;/p&gt;

&lt;p&gt;To achive this I need to have&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;virtual/physical machines&lt;/li&gt;
&lt;li&gt;dhcp + (i)pxe for initial boot and install of coreos&lt;/li&gt;
&lt;li&gt;nginx or haproxy for loadbalancing and as ipxe config provider&lt;/li&gt;
&lt;li&gt;write cloud-configs to configure coreos&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;configuring-dhcp-and-ipxe:ccb8ad9ee70a4495f2af7de194626ecd&#34;&gt;Configuring dhcp and iPXE&lt;/h2&gt;

&lt;p&gt;First step we need to do, after creating VMs, is configure DHCP and iPXE to be able to boot and install CoreOS.
There are a lot of manuals about how to configure dhcp in ubuntu (I&amp;rsquo;m running ubuntu on that machine) I&amp;rsquo;m not going to copy-paste it.
One thing I want to mention is that I hardcoded MAC/IP addresses of 3 my machines which I&amp;rsquo;m going to use as ETCd/Kubernetes masters.&lt;/p&gt;

&lt;p&gt;here is example of dhcp record cofigured for ETCD master:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  host kube-etcd-01 {
      hardware ethernet 01:23:45:67:89:00;
      fixed-address 10.10.30.11;

      if exists user-class and option user-class = &amp;quot;iPXE&amp;quot; {
          filename &amp;quot;http://10.10.30.1:8000/ipxe/ipxe-kube-etcd-01&amp;quot;;
      } else {
          filename &amp;quot;undionly.kpxe&amp;quot;;
      }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and here is example of the &lt;code&gt;ipxe-kube-etcd-01&lt;/code&gt; config:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!ipxe

set base-url http://10.10.30.1:8000
kernel ${base-url}/images/coreos_production_pxe.vmlinuz cloud-config-url=${base-url}/ipxe/cloud-config-bootstrap-etcd-01.sh sshkey=&amp;quot;&amp;lt;YOUR_SSH_KEY&amp;gt;&amp;quot;
initrd ${base-url}/images/coreos_production_pxe_image.cpio.gz
boot

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this file we can see that we will run coreos image with cloud-config and ssh key.
Having your &lt;code&gt;sshkey&lt;/code&gt; here is useful, when for some reason provisioning/install was not successfull and you need to debug.
Also as you can see we&amp;rsquo;re telling coreos to use &lt;code&gt;sh&lt;/code&gt; script as cloud-config. This is done because I want to run coreos-install after boot.
Here is content of &lt;code&gt;cloud-config-bootstrap-etcd-01.sh&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash

curl http://10.10.30.1:8000/ipxe/cloud-config-etcd-01.yml -o cloud-config.yaml
sudo coreos-install -d /dev/sda -c cloud-config.yaml -C alpha
sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This script just downloads real cloud config, installs coreos on disk and reboot.
This also leads to maintaining 3 files for each type of machine, which I really don&amp;rsquo;t like and plan to change/automate.&lt;/p&gt;

&lt;h2 id=&#34;configuring-nginx-to-serve-cloud-configs:ccb8ad9ee70a4495f2af7de194626ecd&#34;&gt;Configuring nginx to serve cloud configs&lt;/h2&gt;

&lt;p&gt;IPXE can serve configs from many locations, I prefer to use http. And since its just plain text files having nxinx is enough for this.
Most of example cloud-cofigs you can find in the internet has references to &lt;code&gt;$private_ipv4&lt;/code&gt; or &lt;code&gt;$public_ipv4&lt;/code&gt; variables.
If you&amp;rsquo;re using cloud providers for your coreos setup, this variables will be translated to real addresses. But since we using baremetal setup we
need to impletement something to have similar behaviour. The easiest way is to use nginx for this.&lt;/p&gt;

&lt;p&gt;Having &lt;code&gt;sub_filter $public_ipv4 &#39;$remote_addr&#39;;&lt;/code&gt; rule in your nginx location block will put ip address of the host requesting the config instead of variable on the fly.&lt;/p&gt;

&lt;p&gt;And again coreos documentaion has example of nginx &lt;a href=&#34;https://coreos.com/os/docs/latest/nginx-host-cloud-config.html&#34;&gt;config location block&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;generate-ssl-certificates-for-master-node-and-admin-user:ccb8ad9ee70a4495f2af7de194626ecd&#34;&gt;Generate ssl certificates for master node and admin user&lt;/h2&gt;

&lt;p&gt;Generation of ssl certificates for kubernetes is described in details on &lt;a href=&#34;https://coreos.com/kubernetes/docs/latest/openssl.html&#34;&gt;coreOS site.&lt;/a&gt;.
So I will just show my ssl config and commands that needs to be run.&lt;/p&gt;

&lt;p&gt;openssl.cnf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[req]
req_extensions = v3_req
distinguished_name = req_distinguished_name
[req_distinguished_name]
[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
subjectAltName = @alt_names
[alt_names]
DNS.1 = kubernetes
DNS.2 = kubernetes.default
DNS.3 = kubernetes.default.svc
DNS.4 = kubernetes.default.svc.cluster.local
DNS.5 = kubernetes.example.com &amp;lt;- my public domain name
IP.1 = 10.100.0.1   &amp;lt;- cluster master ip
IP.2 = 10.10.30.11  &amp;lt;- master/etcd 01
IP.3 = 10.10.30.12  &amp;lt;- master/etcd 02
IP.4 = 10.10.30.13  &amp;lt;- master/etcd 03
IP.5 = 10.10.30.1 &amp;lt;- loadbalancer IP
IP.6 = 111.111.111.111 &amp;lt;- my public IP

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ openssl genrsa -out ca-key.pem 2048
$ openssl req -x509 -new -nodes -key ca-key.pem -days 10000 -out ca.pem -subj &amp;quot;/CN=kube-ca&amp;quot;
$ openssl genrsa -out apiserver-key.pem 2048
$ openssl req -new -key apiserver-key.pem -out apiserver.csr -subj &amp;quot;/CN=kube-apiserver&amp;quot; -config openssl.cnf
$ openssl x509 -req -in apiserver.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out apiserver.pem -days 365 -extensions v3_req -extfile openssl.cnf

# generate admin key to be able to control cluster

$ openssl genrsa -out admin-key.pem 2048
$ openssl req -new -key admin-key.pem -out admin.csr -subj &amp;quot;/CN=kube-admin&amp;quot;
$ openssl x509 -req -in admin.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out admin.pem -days 365
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;writing-cloud-configs:ccb8ad9ee70a4495f2af7de194626ecd&#34;&gt;Writing cloud-configs&lt;/h2&gt;

&lt;p&gt;At this point we have everything in place, except for cloud-configs.
I&amp;rsquo;m not going to describe all parts of cloudconfigs, &lt;a href=&#34;https://coreos.com/os/docs/latest/cloud-config.html&#34;&gt;coreos&lt;/a&gt; did it really great&lt;/p&gt;

&lt;p&gt;Lets start from etcd/master node. There are two ways to configure etcd cluster.
 First is to use initial seed cluster - basicaly you know the nodes and IP addresses of your etcd cluster and just hardcode it in config.
 The second one is to use coreos cloud discovery.&lt;/p&gt;

&lt;p&gt;In depth comparison is available &lt;a href=&#34;https://coreos.com/etcd/docs/latest/clustering.html&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Since I know IP addresses of all my master nodes I&amp;rsquo;m going to use initial seed cluster.&lt;/p&gt;

&lt;p&gt;My etcd configuration block looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;#cloud-config

hostname: etcd01
coreos:
  etcd2:
    name: etcd01
    listen-client-urls: http://$public_ipv4:2379,http://127.0.0.1:2379
    advertise-client-urls: http://$public_ipv4:2379
    initial-cluster-token: my-kubernetes-cluster
    listen-peer-urls: http://$public_ipv4:2380
    initial-advertise-peer-urls: http://$public_ipv4:2380
    initial-cluster: etcd01=http://10.10.30.11:2380,etcd02=http://10.10.30.12:2380,etcd03=http://10.10.30.13:2380
    initial-cluster-state: new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now lets take a look what we need to add here to run kubernetes master services on the same node:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We need to put our ssl certificates&lt;/li&gt;
&lt;li&gt;Download kubernetes binaries&lt;/li&gt;
&lt;li&gt;Write systemD units&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lets start with certificates.
To put it on the machine we can either download it from somewhere during boot or just hardcode it into cloudconfig.
For now I&amp;rsquo;m going to use second option.&lt;/p&gt;

&lt;p&gt;To do this, lets add &lt;code&gt;write-files:&lt;/code&gt; block to our cloudconfig:
Since we already generated all ssl certificates, we just need to copy-paste the content to corresponding blocks.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  - path: /etc/kubernetes/ssl/ca.pem
    owner: core
    permissions: 0644
    content: |
      -----BEGIN CERTIFICATE-----
      -----END CERTIFICATE-----

  - path: /etc/kubernetes/ssl/apiserver-key.pem
    owner: core
    permissions: 0644
    content: |
      -----BEGIN CERTIFICATE-----
      -----END CERTIFICATE-----

  - path: /etc/kubernetes/ssl/apiserver.pem
    owner: core
    permissions: 0644
    content: |
      -----BEGIN CERTIFICATE-----
      -----END CERTIFICATE-----

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having something in &lt;code&gt;write-files&lt;/code&gt; is a convenient way for adding something to the system during boot.&lt;/p&gt;

&lt;p&gt;Lets create write another file, which will be responsible for checking availability of needed port.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  - path: /opt/bin/wupiao
    permissions: &#39;0755&#39;
    content: |
      #!/bin/bash
      # [w]ait [u]ntil [p]ort [i]s [a]ctually [o]pen
      [ -n &amp;quot;$1&amp;quot; ] &amp;amp;&amp;amp; \
        until curl -o /dev/null -sIf http://${1}; do \
          sleep 1 &amp;amp;&amp;amp; echo .;
        done;
      exit $?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we need to download kubernetes binaries, lets write another file for this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  - path: /opt/bin/kubernetes-install.sh
    owner: root
    permissions: 0755
    content: |
      #! /usr/bin/bash
      sudo mkdir -p /etc/kubernetes/manifests/
      sudo mkdir -p /etc/kubernetes/ssl/
      sudo mkdir -p /etc/kubernetes/addons/

      if [ ! -f /opt/bin/kubelet ]; then
        echo &amp;quot;Kubenetes not installed - installing.&amp;quot;

        export K8S_VERSION=$(curl -sS https://storage.googleapis.com/kubernetes-release/release/stable.txt)

        # Extract the Kubernetes binaries.
        sudo wget -N -P /opt/bin http://storage.googleapis.com/kubernetes-release/release/${K8S_VERSION}/bin/linux/amd64/kubectl
        sudo wget -N -P /opt/bin http://storage.googleapis.com/kubernetes-release/release/${K8S_VERSION}/bin/linux/amd64/kubelet
        sudo wget -N -P /opt/bin http://storage.googleapis.com/kubernetes-release/release/${K8S_VERSION}/bin/linux/amd64/kube-apiserver
        sudo wget -N -P /opt/bin http://storage.googleapis.com/kubernetes-release/release/${K8S_VERSION}/bin/linux/amd64/kube-controller-manager
        sudo wget -N -P /opt/bin http://storage.googleapis.com/kubernetes-release/release/${K8S_VERSION}/bin/linux/amd64/kube-scheduler
        sudo chmod +x /opt/bin/kubelet /opt/bin/kubectl /opt/bin/kube-apiserver /opt/bin/kube-controller-manager /opt/bin/kube-scheduler
      fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Script is simple, create needed folders and if download binaries if needed.
K8S_VERSION will have the latest stable version of kubernetes. We will configure coreos to run this script during boot.
Now when all files are in place we just need to configure systemD units to start everything.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;coreos:
  ...
  units:
    - name: kubernetes-install.service
      runtime: true
      command: start
      content: |
        [Unit]
        Description=Installs Kubernetes tools

        [Service]
        ExecStart=/opt/bin/kubernetes-install.sh
        RemainAfterExit=yes
        Type=oneshot
    - name: setup-network-environment.service
      command: start
      content: |
        [Unit]
        Description=Setup Network Environment
        Documentation=https://github.com/kelseyhightower/setup-network-environment
        Requires=network-online.target
        After=network-online.target

        [Service]
        ExecStartPre=-/usr/bin/mkdir -p /opt/bin
        ExecStartPre=/usr/bin/curl -L -o /opt/bin/setup-network-environment https://github.com/kelseyhightower/setup-network-environment/releases/download/1.0.1/setup-network-environment
        ExecStartPre=/usr/bin/chmod +x /opt/bin/setup-network-environment
        ExecStart=/opt/bin/setup-network-environment
        RemainAfterExit=yes
        Type=oneshot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets start with this two. First one will run our kubernetes installer, and the second one will create network environment file.
Which is very helpful in some cases. For example you can have your current IP address as environment variable.&lt;/p&gt;

&lt;p&gt;And of course we need to run kubernetes services:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;    - name: kube-apiserver.service
      command: start
      content: |
        [Unit]
        Description=Kubernetes API Server
        Documentation=https://github.com/kubernetes/kubernetes
        Requires=setup-network-environment.service etcd2.service fleet.service docker.service flanneld.service kubernetes-install.service
        After=setup-network-environment.service etcd2.service fleet.service docker.service flanneld.service kubernetes-install.service

        [Service]
        EnvironmentFile=/etc/network-environment
        ExecStartPre=-/usr/bin/mkdir -p /opt/bin
        ExecStartPre=/opt/bin/wupiao 127.0.0.1:2379/v2/machines
        ExecStart=/opt/bin/kube-apiserver \
          --admission_control=NamespaceLifecycle,NamespaceExists,LimitRanger,SecurityContextDeny,ServiceAccount,ResourceQuota \
          --service-account-key-file=/etc/kubernetes/ssl/apiserver-key.pem \
          --tls-private-key-file=/etc/kubernetes/ssl/apiserver-key.pem \
          --tls-cert-file=/etc/kubernetes/ssl/apiserver.pem \
          --client-ca-file=/etc/kubernetes/ssl/ca.pem \
          --apiserver-count=3 \
          --advertise-address=${DEFAULT_IPV4} \
          --allow_privileged=true \
          --insecure_bind_address=0.0.0.0 \
          --insecure_port=8080 \
          --kubelet_https=true \
          --secure_port=443 \
          --service-cluster-ip-range=10.100.0.0/16 \
          --etcd_servers=http://127.0.0.1:2379 \
          --bind-address=0.0.0.0 \
          --cloud_provider=&amp;quot;&amp;quot; \
          --logtostderr=true \
          --runtime_config=api/v1
        Restart=always
        RestartSec=10
    - name: kube-controller-manager.service
      command: start
      content: |
        [Unit]
        Description=Kubernetes Controller Manager
        Documentation=https://github.com/kubernetes/kubernetes
        Requires=kubernetes-install.service kube-apiserver.service
        After=kubernetes-install.service kube-apiserver.service
        Requires=setup-network-environment.service
        After=setup-network-environment.service

        [Service]
        EnvironmentFile=/etc/network-environment
        ExecStartPre=/opt/bin/wupiao ${DEFAULT_IPV4}:8080
        ExecStart=/opt/bin/kube-controller-manager \
          --service-account-private-key-file=/etc/kubernetes/ssl/apiserver-key.pem \
          --root-ca-file=/etc/kubernetes/ssl/ca.pem \
          --master=${DEFAULT_IPV4}:8080 \
          --cloud_provider=&amp;quot;&amp;quot; \
          --pod_eviction_timeout=30s \
          --leader-elect \
          --logtostderr=true
        Restart=always
        RestartSec=10
    - name: kube-scheduler.service
      command: start
      content: |
        [Unit]
        Description=Kubernetes Scheduler
        Documentation=https://github.com/kubernetes/kubernetes
        Requires=kubernetes-install.service kube-apiserver.service
        After=kubernetes-install.service kube-apiserver.service
        Requires=setup-network-environment.service
        After=setup-network-environment.service

        [Service]
        EnvironmentFile=/etc/network-environment
        ExecStartPre=/opt/bin/wupiao ${DEFAULT_IPV4}:8080
        ExecStart=/opt/bin/kube-scheduler --leader-elect --master=${DEFAULT_IPV4}:8080
        Restart=always
        RestartSec=10

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Everything here is relatively simple, and could be found in almost eny example of cloud config. But few things I want to highlight.
&lt;code&gt;${DEFAULT_IPV4}&lt;/code&gt; variable is populated by &lt;code&gt;setup-network-environment.service&lt;/code&gt; we created earlier. We can use either this or our nginx configuration.
Also I have &lt;code&gt;--insecure_bind_address=0.0.0.0&lt;/code&gt; inside &lt;code&gt;kube-apiserver.service&lt;/code&gt;,
because currently I have isolated network, and my nodes can&amp;rsquo;t be accessed from the internet. Otherwise it should contain your internal IP or localhost.&lt;/p&gt;

&lt;p&gt;The last thing, is &lt;code&gt;--apiserver-count=3&lt;/code&gt;. If you have more than one master, you should set this parameter to avoid problems.&lt;/p&gt;

&lt;p&gt;Complete cloud-config could be found in &lt;a href=&#34;#&#34;&gt;github repository&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all for masters. At this stage we can start all 3 master master-nodes.
After several minutes you should have working etcd cluster with kubernetes cluster.
But we have not minions, only masters. So lets go through configuratino of minions.&lt;/p&gt;

&lt;h4 id=&#34;configuring-minions:ccb8ad9ee70a4495f2af7de194626ecd&#34;&gt;Configuring minions&lt;/h4&gt;

&lt;p&gt;Since we want to have any number of minions and be able to add/remove it at any time, config should be the same for all, without any hardcoding.
That&amp;rsquo;s why will generate client&amp;rsquo;s ssl certicates during install.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  - path: /etc/kubernetes/ssl/worker-openssl.cnf
    owner: root
    permissions: 0755
    content: |
      [req]
      req_extensions = v3_req
      distinguished_name = req_distinguished_name
      [req_distinguished_name]
      [ v3_req ]
      basicConstraints = CA:FALSE
      keyUsage = nonRepudiation, digitalSignature, keyEncipherment
      subjectAltName = @alt_names
      [alt_names]
      IP.1 = $ENV::WORKER_IP
  - path: /etc/kubernetes/ssl/generate-tls-keys.sh
    owner: root
    permissions: 0755
    content: |
      #! /usr/bin/bash
      # Generates a set of TLS keys for this node to access the API server.
      set -e
      if [ ! -f /etc/kubernetes/ssl/worker.pem ]; then
        echo &amp;quot;Generating TLS keys.&amp;quot;
        cd /etc/kubernetes/ssl
        openssl genrsa -out worker-key.pem 2048
        WORKER_IP=${1} openssl req -new -key worker-key.pem -out worker.csr -subj &amp;quot;/CN=worker&amp;quot; -config worker-openssl.cnf
        WORKER_IP=${1} openssl x509 -req -in worker.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out worker.pem -days 365 -extensions v3_req -extfile worker-openssl.cnf
      fi
      # Set permissions.
      sudo chmod 600 /etc/kubernetes/ssl/worker-key.pem
      sudo chown root:root /etc/kubernetes/ssl/worker-key.pem

  - path: /etc/kubernetes/ssl/ca.pem
    owner: core
    permissions: 0644
    content: |
      -----BEGIN CERTIFICATE-----
      -----END CERTIFICATE-----
  - path: /etc/kubernetes/ssl/ca-key.pem
    owner: core
    permissions: 0644
    content: |
      -----BEGIN RSA PRIVATE KEY-----
      -----END RSA PRIVATE KEY-----
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also we need to have scripts to check ports and install kubernetes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  - path: /opt/bin/wupiao
    permissions: &#39;0755&#39;
    content: |
      #!/bin/bash
      # [w]ait [u]ntil [p]ort [i]s [a]ctually [o]pen
      [ -n &amp;quot;$1&amp;quot; ] &amp;amp;&amp;amp; \
        until curl -o /dev/null -sIf http://${1}; do \
          sleep 1 &amp;amp;&amp;amp; echo .;
        done;
      exit $?

  - path: /opt/bin/kubernetes-install.sh
    owner: root
    permissions: 0755
    content: |
      #! /usr/bin/bash
      set -e

      if [ ! -f /opt/bin/kubelet ]; then
        echo &amp;quot;Kubenetes not installed - installing.&amp;quot;

        export K8S_VERSION=$(curl -sS https://storage.googleapis.com/kubernetes-release/release/stable.txt)

        # Extract the Kubernetes binaries.
        sudo wget -N -P /opt/bin http://storage.googleapis.com/kubernetes-release/release/${K8S_VERSION}/bin/linux/amd64/kubelet
        sudo wget -N -P /opt/bin http://storage.googleapis.com/kubernetes-release/release/${K8S_VERSION}/bin/linux/amd64/kube-proxy
        sudo chmod +x /opt/bin/kubelet /opt/bin/kube-proxy

        # Create required folders
        sudo mkdir -p /etc/kubernetes/manifests/
        sudo mkdir -p /etc/kubernetes/ssl/
      fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also we are going to run etcd on all nodes, but not the same way as on masters, here we will run it in proxy mode&lt;/p&gt;

&lt;h1 id=&#34;todo-write-about-proxy-mode:ccb8ad9ee70a4495f2af7de194626ecd&#34;&gt;TODO: write about proxy mode&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  etcd2:
    listen-client-urls: http://0.0.0.0:2379,http://0.0.0.0:4001
    initial-cluster: etcd01=http://10.10.30.11:2380,etcd02=http://10.10.30.12:2380,etcd03=http://10.10.30.13:2380
    advertise-client-urls: http://0.0.0.0:2379,http://0.0.0.0:4001
    proxy: on
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All SystemD units for minions is self describing and has nothing special.
The only thing worth mentionioing is DNS. It took me few days to understand this
chicken-egg problem. Kubernetes by itself has no DNS service, and you should install it afterwads.
In fact it is really easy - just create service and replication controller from receipts,
you can find in the kubernetes repository.
But, you need to decide about your internal domain zone and service IP address of your dns server
before you create your minions and hardcode it in your kubelet config.
So you need minion to deploy dns service, but you need to configure minion to know IP address of the future DNS.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ExecStart=/opt/bin/kubelet \
    ...
    --cluster_dns=10.100.0.10 \
    --cluster_domain=cluster.local \
    ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Complete cloud-config for minions could be found &lt;a href=&#34;#&#34;&gt;on github&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;checking-that-evething-works:ccb8ad9ee70a4495f2af7de194626ecd&#34;&gt;Checking that evething works&lt;/h1&gt;

&lt;p&gt;First of all we need to install &lt;code&gt;kubectl&lt;/code&gt; tool to be able to talk to our cluster.&lt;/p&gt;

&lt;p&gt;There are two ways you can talk to your cluster - first is secured channel using ssl keys we generated
earlie and the second one using insecure port 8080, but only in case you configured kube-apiserver
to listen anything other than localhost.&lt;/p&gt;

&lt;p&gt;This is perfectly described at &lt;a href=&#34;#&#34;&gt;documentation&lt;/a&gt;
After following documentaion you should be able to execute &lt;code&gt;kubectl&lt;/code&gt; command and have config at &lt;code&gt;~/.kube/config&lt;/code&gt; with something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Config
clusters:
- cluster:
    certificate-authority: ssl/ca.pem
    server: https://10.10.30.12:443
  name: my-cluster
contexts:
- context:
    cluster: my-cluster
    namespace: default
    user: admin
  name: dev
users:
- name: admin
  user:
    client-certificate: ssl/admin.pem
    client-key: ssl/admin-key.pem
current-context: dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, if you run &lt;code&gt;kubectl get nodes&lt;/code&gt; you should get back a list of your nodes with IP addresses.
If not - something went wrong and you should check the logs and try to fix it :)&lt;/p&gt;

&lt;p&gt;Of course feel free to ping me and I&amp;rsquo;ll try to help.&lt;/p&gt;

&lt;p&gt;Since it already a huge post, I&amp;rsquo;m going to finish it here.
At this point we have fully operational cluster with several masters and several minions.
In the next post I will walk through deploying some basic services like: dns, heapster, dashboards and logs collecting.&lt;/p&gt;

&lt;h2 id=&#34;problems-during-deploy:ccb8ad9ee70a4495f2af7de194626ecd&#34;&gt;Problems during deploy&lt;/h2&gt;

&lt;h3 id=&#34;resetting-endpoints-for-master-service-kubernetes:ccb8ad9ee70a4495f2af7de194626ecd&#34;&gt;Resetting endpoints for master service &amp;ldquo;kubernetes&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;After deploing multiple masters I saw this message every minute or so&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Apr 17 11:48:34 etcd01 kube-apiserver[1040]: W0417 11:48:34.571681    1040 controller.go:297] Resetting endpoints for master service &amp;quot;kubernetes&amp;quot; to &amp;amp;{{ } {kubernetes  default  f76faadd-0487-11e6-8614-000c29d236c7 7314 0 2016-04-17 10:34:29 +0000 UTC &amp;lt;nil&amp;gt; &amp;lt;nil&amp;gt; map[] map[]} [{[{10.10.30.11 &amp;lt;nil&amp;gt;}] [] [{https 443 TCP}]}]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As said in &lt;a href=&#34;https://github.com/openshift/origin/issues/6073&#34;&gt;https://github.com/openshift/origin/issues/6073&lt;/a&gt; this happens when&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The controller running on each master that ensures that all masters IP&amp;rsquo;s are present in the kubernetes endpoints looks at two things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;the current master&amp;rsquo;s IP in the list&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;the number of IPs in the list exactly matching the masterCount&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;In my case it happened because I didn&amp;rsquo;t add flag &lt;code&gt;--apiserver-count=N&lt;/code&gt; to &lt;code&gt;kube-apiserver&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/opt/bin/kube-apiserver --apiserver-count=N
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ignoring-not-a-miss:ccb8ad9ee70a4495f2af7de194626ecd&#34;&gt;Ignoring not a miss&lt;/h3&gt;

&lt;p&gt;This one I still didn&amp;rsquo;t fix, luckily it doesn&amp;rsquo;t cause any major problems.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Apr 18 07:59:11 etcd01 sdnotify-proxy[866]: I0418 07:59:11.903461 00001 vxlan.go:340] Ignoring not a miss: aa:25:34:2a:9c:7a, 10.3.77.10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One hint, which is kind of obvious, but in fact it saved me a lot of time.
Since you will create/destroy CoreOS instances tens or even hundreds of times - add this block to your ssh config to avoid deleting hosts from known_hosts file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Host 10.10.30.*
   StrictHostKeyChecking no
   UserKnownHostsFile=/dev/null
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Move infrastructure to Kubernetes. Basic services.</title>
      <link>http://blog.lwolf.org/post/move-infrastructure-to-kubernetes-part2/</link>
      <pubDate>Mon, 25 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.lwolf.org/post/move-infrastructure-to-kubernetes-part2/</guid>
      <description>

&lt;p&gt;In previous &lt;a href=&#34;#&#34;&gt;post&lt;/a&gt; I finished description of installation and configuation of kubernetes cluster.
We also can talk to our cluster using &lt;code&gt;kubectl&lt;/code&gt;.
In this one I&amp;rsquo;m going to talk about installation on basic services into it.
For example DNS, heapster and different dashboards.
&lt;!-- more --&gt;&lt;/p&gt;

&lt;h1 id=&#34;deploying-addon-services:90953e0ebbc25ecf0c01d4ed700f3e09&#34;&gt;Deploying addon services&lt;/h1&gt;

&lt;h3 id=&#34;creating-system-namespace:90953e0ebbc25ecf0c01d4ed700f3e09&#34;&gt;Creating system namespace&lt;/h3&gt;

&lt;p&gt;Kubernetes comes with several very useful addons, which still needs to be installed.
Kubernetes itself has only one &lt;a href=&#34;#&#34;&gt;namespace&lt;/a&gt; called &lt;code&gt;default&lt;/code&gt; but for most of the addons
and other system services it requires another one called &lt;code&gt;kube-system&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can check which namespaces you already have in your cluster bu running &lt;code&gt;kubectl get namespaces&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If kube-system is not among them you need to create it to be able to deploy addons.
To do it you need to create simple yaml(or json) file and run it.&lt;/p&gt;

&lt;p&gt;Lets say you have file &lt;code&gt;kube-system.yaml&lt;/code&gt; with the following content.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;kind: Namespace
apiVersion: v1
metadata:
  name: kube-system

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you need to deploy it to the cluster:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl create -f kube-system.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thats it, after this if you run &lt;code&gt;kubectl get namespaces&lt;/code&gt; you will have one more namespace.&lt;/p&gt;

&lt;h3 id=&#34;deploying-dns-service:90953e0ebbc25ecf0c01d4ed700f3e09&#34;&gt;Deploying DNS service&lt;/h3&gt;

&lt;p&gt;This one is also part of the standard addons available in kubernetes repository.
If you&amp;rsquo;re using default ip address for dns (10.100.0.10) and
default cluster name (cluster.local) you can just deploy it from there.
Otherwise you need to change rc file to match your settings.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd kubernetes/cluster/addons

kubectl --namespace=kube-system create -f skydns-rc.yaml
kubectl --namespace=kube-system create -f skydns-svc.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;deploy-kubernetes-dashboards:90953e0ebbc25ecf0c01d4ed700f3e09&#34;&gt;Deploy kubernetes dashboards&lt;/h3&gt;

&lt;p&gt;Now we want to have nice dashboards to monitor our cluster and may be even deploy new services.
For this kubernetes has two default dashboards. One is the part of addons,
and the other one is like new one, which has its own &lt;a href=&#34;#&#34;&gt;repository&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd kubernetes/cluster/addons
kubectl create -f kube-ui/

kubectl create -f https://rawgit.com/kubernetes/dashboard/master/src/deploy/kubernetes-dashboard.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To access first one you need to run &lt;code&gt;kubectl cluster-info&lt;/code&gt; to find out its url.
The second one will be deployed to random node and port,
and to find it out you can run &lt;code&gt;kubectl describe service kubernetes-dashboard --namespace=kube-system&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;deploying-heapster:90953e0ebbc25ecf0c01d4ed700f3e09&#34;&gt;Deploying heapster&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;#&#34;&gt;Heapster&lt;/a&gt; is one of the systems used in kubernetes to collect metrics.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone heapster
cd heapster
kubectl create -f deploy/heapster
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Heapster uses grafana dashboard to show its metrics, but there is also another dashboard available - kubedash&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone kubedash
cd kubedash
kubectl create -f deploy/bundle.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To find out where kubedash is available, run - &lt;code&gt;kubectl describe ????&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;deploy-newrelic-daemon:90953e0ebbc25ecf0c01d4ed700f3e09&#34;&gt;Deploy newrelic daemon&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m using newrelic service all the time to monitor my applications and servers.
So I&amp;rsquo;m going to run it as a daemon on all minions.&lt;/p&gt;

&lt;p&gt;Newrelic configuration I&amp;rsquo;m going to deploy, with good readme btw, could be found in &lt;a href=&#34;#&#34;&gt;kubernetes/examples&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Shortly, to run newrelic you need to create config file and then create a base64 hash of it, after this you can deploy it.
We need linux machine to create base64 hash of our config and then deploy it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl create -f newrelic-config.yaml
kubectl create -f newrelic-daemonset.yaml --validate=false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;deploy-fluentd-logging:90953e0ebbc25ecf0c01d4ed700f3e09&#34;&gt;Deploy fluentd-logging&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;kubectl create -f fluentd-elasticsearch/
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Move infrastructure to Kubernetes. LoadBalancing.</title>
      <link>http://blog.lwolf.org/post/move-infrastructure-to-kubernetes-part3/</link>
      <pubDate>Mon, 25 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.lwolf.org/post/move-infrastructure-to-kubernetes-part3/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h1 id=&#34;configuring-ingress-and-loadbalancing:1486a6b0ad319ffd0831241316b8161c&#34;&gt;Configuring ingress and loadbalancing&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;kubectl create -f ./ingress-lb/default-backend.yaml
kubectl expose rc default-http-backend --port=80 --target-port=8080 --name=default-http-backend
kubectl create -f ./ingress-lb/nginx-ingress-daemonset.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;testing-staging-environment:1486a6b0ad319ffd0831241316b8161c&#34;&gt;Testing/Staging environment&lt;/h1&gt;

&lt;h2 id=&#34;install-needed-services:1486a6b0ad319ffd0831241316b8161c&#34;&gt;install needed services&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;create separate namespace&lt;/li&gt;
&lt;li&gt;install gitlab&lt;/li&gt;
&lt;li&gt;install jenkins&lt;/li&gt;
&lt;li&gt;install docker-hub&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;create-repositories-and-build-jobs:1486a6b0ad319ffd0831241316b8161c&#34;&gt;create repositories and build jobs&lt;/h2&gt;

&lt;h2 id=&#34;configure-autobuild-autodeploy-to-staging:1486a6b0ad319ffd0831241316b8161c&#34;&gt;Configure autobuild/autodeploy to staging&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Move infrastructure to Kubernetes. Staging/Testing infrastucture.</title>
      <link>http://blog.lwolf.org/post/move-infrastructure-to-kubernetes-part4/</link>
      <pubDate>Mon, 25 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.lwolf.org/post/move-infrastructure-to-kubernetes-part4/</guid>
      <description>

&lt;h1 id=&#34;testing-staging-environment:cf11c1150ad8013d1c5d1262782aa03f&#34;&gt;Testing/Staging environment&lt;/h1&gt;

&lt;h2 id=&#34;install-needed-services:cf11c1150ad8013d1c5d1262782aa03f&#34;&gt;install needed services&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;create separate namespace&lt;/li&gt;
&lt;li&gt;install gitlab&lt;/li&gt;
&lt;li&gt;install jenkins&lt;/li&gt;
&lt;li&gt;install docker-hub&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;create-repositories-and-build-jobs:cf11c1150ad8013d1c5d1262782aa03f&#34;&gt;create repositories and build jobs&lt;/h2&gt;

&lt;h2 id=&#34;configure-autobuild-autodeploy-to-staging:cf11c1150ad8013d1c5d1262782aa03f&#34;&gt;Configure autobuild/autodeploy to staging&lt;/h2&gt;

&lt;!-- more --&gt;
</description>
    </item>
    
  </channel>
</rss>